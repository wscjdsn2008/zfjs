<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    
    <script>
        //### 数字类型：常规数字, NaN(NaN也是数字类型)
        // NAN和任何值(包括它自己)都不相等
        // console.log('aa'==NaN);//false
        // console.log(10==NaN);//false
        // console.log(NaN==NaN);//false

        //### isNaN() 检测是否为非有效数字.不是有效数字,返回true,反之为false.
        // isNaN()检测时如果不是数字类型,会基于Number()方法把值转换成数字类型,再检测
        // console.log(isNaN('10'));//false  //先转成10再检测
        // console.log(isNaN(10));//false
        // console.log(isNaN('10abc'));//true
        // console.log(isNaN(NaN));//true
        // console.log(isNaN(false));//false
        // console.log(isNaN(true));//false
        // console.log(isNaN(''));//false
        // console.log(isNaN({}));//true
        // console.log(isNaN([]));//false


        // ### Number() 其他类型值转换成数字.被转换的值整体必须是数字才能转,否则就是NaN
        // console.log(Number('12.5'));//12.5
        // console.log(Number('12.5px'));//NaN
        // console.log(Number('12.5.5'));//NaN
        // console.log(Number(true));//1
        // console.log(Number(false));//0
        // console.log(Number(''));//0
        // console.log(Number(null));//0
        // console.log(Number([]));//0
        // console.log(Number([12,23]));//NaN
        // console.log(Number({}));//NaN
        // console.log(Number(undefined));//NaN
        //console.log(Number(NaN));//NaN
        // console.log(10+undefined);//NaN
        // console.log('10'+undefined);//"10undefined"

        // console.log([] + 1);
        // console.log([123] + 1);
        // console.log("1" + [123] );
        // console.log("1" + [,,,] );
        // console.log("1" + [123,456,789,'aaa']);
 
        //引用数据类型(包含函数,对象)转换为数字,先把它基于toString()
        // 方法转换成字符串,然后再转成数字.对象,函数,正则转成数字都是NaN
        // 对象.toString()=>"[object Object]"
        // console.log(Number({}));//NaN
        // console.log(Number({age:10}));//NaN

        // [].toString()=>'',
        // console.log(Number([]));//0
        // [12].toString()=>'12'
        // console.log(Number([12]));//12
        // [12,23].toString()=>'12,23'
        // console.log(Number([12,23]));//NaN
  
        // parseInt/parseFloat:将字符串转数字时,是从左到右依次查找有效数字
        // 进行转换,只要遇到非有效数字,就停止查找.(结果不是数字就是NaN)
        // console.log(parseFloat('12.5px'));//12.5
        // console.log(parseFloat('width:12.5px'));//NaN
        // console.log(parseFloat(true));//NaN  相当于parseFloat('true'),第一个字母t就是非有效数字,所以返回NaN
        // console.log(parseInt(null));//NaN 
        // console.log(parseInt(undefined));//NaN 
        // console.log(parseInt([]));//NaN 
        // console.log(parseInt({}));//NaN 
        // console.log(parseInt(''));//NaN 

        // ==进行比较的时候,也可能出现把其他类型的值转成数字   
        // 10=="10" //true
        // console.log(null==undefined);//true
        // console.log(null===undefined);//false


    
        //### 其他类型转字符串  1.[val].toString()   2.字符串拼接 
    // var a=15
    // console.log(a.toString());// '15'
    // console.log(NaN.toString());//'NaN'
    // console.log(true.toString());//'true'
    // console.log([].toString());//  ''
    // console.log({}.toString());//"[object Object]"
    // console.log(/^$/.toString());//  "/^$/"
    // // null和undefined禁止直接使用toString()方法,会报错
   
    /**四则运算除了加法,其余都是数学运算,只有加法可能存在字符串拼接
     * 加法一旦遇到字符串,则是字符串拼接*/
    //  console.log('10'+10);//1010
    //  console.log('10'-10);//0
    //  console.log('10px'-10);//NaN
    // console.log(undefined+{});
// console.log(100+true+21.2+null+undefined+"Tencent"+[]+null+9+false);//" NaNTencentnull9false"

// 15课的各种类型数据相加的计算题重点看下



// console.log(typeof ('10'+[]));//10 string
// console.log(typeof (10+[]));//10 string
// console.log(10+{});//10[object Object]
// console.log('10'+{});//10[object Object]
// console.log({}+[]);
// console.log([]+{});
// console.log(1+[10]);

    // 其他类型转布尔值
    // 0,NaN,'',null,undefined五个值转布尔值是false,其他全是true,没有任何特殊情况
    // console.log(Boolean(' '));//true,不是空字符串
    // console.log(Boolean([]));//true
    // console.log(Boolean({}));//true
        // console.log(!1);//false
        // console.log(!!1);//true
        // console.log(!0);//true
        // console.log(!NaN);//true
        // if('3px'+3){//3px3 true
        //     console.log('hh');
        // }
        // if('3px'-3){//NaN false
        //     console.log('zwt');
        // }


        /**null和undefined都代表的是没有
         * null:意料之中(一开始手动设置为null,后期在赋值操作)
         * let num=null/let num=0  一般最好用null来初始化空值,因为0不是空值,它在栈内存中有自己的存储空间(占了位置)
         * UNdefined:意料之外(不是我能决定的)
         * / 
          
 
         // console.log(null==undefined);//true
        // console.log(null===undefined);//false
        // console.log(!NaN);//true
        // console.log(!!NaN);//false
        // console.log(Boolean(0));//false
        //  console.log(Boolean('0'));//true




    // ### 对象  一个对象的属性名只有两种格式:字符串或者数字
    // let person={
    //     name:'hh',
    //     age:12,
    //     1:100,
    //     true:100,
    //     undefined:99,
    //     null:98,  
    //     NaN:97,
    //     [12]:96,
    //    age:1===1?100:200,
    //    '':'婷婷',
    //     //[]:96,//不支持空数组
    //     // [12,33]:96// 不支持多个元素
    //     // {}:96,//不支持对象
    //     // {sex:'男'}//不支持对象
    // }
    // console.log(person);
    // console.log(person.name);
    // console.log(person['age']);
    // console.log(person[1]);//键名是数字,只能用[]访问
    // console.log(person.sex);//undefined
    // person.friend='zwt'//添加属性
    // person.age=22 //修改属性
    // person.name=null //属性名还在,只删除属性值
    // console.table(person);
    // delete person.name//同时删除属性名和属性值
    // console.log(person);

    // ###数组: 特殊的对象数据类型
    // let ary=[1,true,{},'hh']
    //数组长度的两种写法
    //console.log(ary['length']);
    //console.log(ary.length);
    // ary[ary.length]='最后一位'//末尾添加元素
    // console.log(ary);

    /**### 数据类型检测 
     *  typeof [val] :检测数据类型的运算符
     * console.log(typeof NaN);// number
     * console.log(typeof undefind);//undefined
     * console.log(typeof function(){})//function
     * 局限性: 
     * 1. typeof null=>'object',但是null不是对象,它是空对象指针
     * 2. typeof [],typeof {},typeof /^/等,都返回object,无法详细区分具体是哪种对象.
     * typeof出现2次及2次以上,都返回'string'
     *
   */
    //instanceof  检测当前实例是否隶属于某个类
    //constructor  基于构造函数检测数据类型(也是基于类的方式)
    //Object.prototy pe.toString.call():用于检测数据类型的最好的办法

  
    //  let a=10
    // if(a>0 && a<20){
    //     a++
    //     console.log(a);
    // }
    //改写上面的写法 ,多个语句用()括起来,用,分割,如果不需要处理事情,用null或者undefined占位
    // a>0 && a<20 ? (a++,console.log(a)):null
    //或者
    // a>0 && a<20 ? (a++,console.log(a)):undefind

    // a>0?(a<10?a++:a--):(a>-10?a+=2:null)


    //switch语言不加break,满足条件的先执行,然后后面的语句即使不满足也会被执行,直到遇到break为止.
    // 即break会向下穿透(不加break可以实现变量在某些值的情况下做相同的事情)
    //每一种情况的比较用的都是 ===, 值和类型都必须相等. if语句中,'5'==5结果是true,但switch中是false
    // let a=10
    // switch (a) {
    //     case 1:
    //     case 2:
    //         a+=1
    //         console.log(a);
    //     case 3:
    //         a*=2
    //         console.log(a);
    //     case 10:
    //         a--
    //         console.log('-- ',a);//-- 9
    //     case 11:
    //         a*=2
    //         console.log(a);//18
    //     case 13:
    //         a++
    //         console.log(a);//19
    //     default:
    //         console.log('hh');//hh
    // }


    // 购物车小案例没做  元素.style.xxx='xxx'是修改某一元素的样式值,
    // 如果没有把样式写在行内上,那么,元素.style.xxx无法获取到样式值
    

    //29课是重点,认真看.


    //如果设置了形参变量,但执行时并没有传递对应的实参值,那么形参变量默认值就是undefined

    // function sum(n,m){
        //形参默认值处理
    //     if(n===undefined){//不能用==,因为null==undefined
    //         n=0
    //     }
    //     if(typeof m==='undefined'){
    //         m=0
    //     }
    //     return n+m
    // }
    //不写return,函数默认return undefined

// (function(n){
//     console.log('匿名函数自执行函数',n);
// })(100)//100是传的实参


    // 37-38重点(选项卡自定义属性)

    // console.log/dir(输出一个对象的详细键值对信息)/table(把一个多维json数组以表格形式展示)
    // alert/confirm/prompt 三种方式输出的结果都必须经过toString()转换为字符串,且都会阻断后面代码的执行



    // 42-45课计算题重点
    // js中的加减乘除本应进行数学运算,如果遇到的值不是数字类型,需要基于Number()方法把它转为数字,
    // 再进行运算;但js中的加法有特殊情况:相加过程中遇到字符串,直接变成字符串拼接.
    
    // let i='10'
    // i+=1 //i=>'101'
    // i=i+1 //i=>'101'
    // i++  //i=>11 i++完全就是数学运算,和上面不同
    //i--  // i=>9
    //console.log(i);
       

// 元素.style.xxx只能获取行内样式,如果没有,获得的是空(颜色在样式中使用16进制,js获取到的是RGB的值)

// 47练习题课重点  48课算工资年薪没做

// for in 遍历对象(break和continue同样适用),且优先循环数字属性名(数字从小到大)
var object={
    name:'hh',
    age:18,
    1:100
}
//打印的结果是
// 1---100   //数字属性名优先被循环
// name---hh
// age---18
for (var key in object) {
    console.log(`${key}---${object[key]}`);//注意obj[key] 和  obj['key']/obj.key的区别 
}



// 50课用的自定义属性设置颜色

/**53课 arguments:函数内置实参集合
 * 1.类数组集合,集合中存储中所有函数执行时,传递的实参信息
 * 2.不论是否设置形参,arguments都存在
 * 3.不论是否传递实参,arguments都存在
 * arguments.callee  存储的是当前函数本身(一般不用,JS严格模式下禁止使用,会报错)
 */
// function sum(){
//     var sum=0
//     for(var i=0;i<arguments.length;i++){
//         var n=Number(arguments[i])
//         if(isNaN(n)){
//             continue;
//         }
//         sum+=n
//     }
//     return sum;
// }
// var sum=sum(10,"aa",20,'null','3',true)//34
// console.log(sum);


// function fn(m){
//     return function(n){
//         return m+n
//     }
// }
//改写箭头函数 let fn=m=>n=>m+n

//使用剩余运算符
// var fn=(...hh)=>eval(hh.join('+'))
// console.log(fn(10,5));



// Math是一个对象
//先基于Number()转成数字
// console.log(typeof Math);//'object'
// console.log(Math.abs(''));//0
// console.log(Math.abs(null));//0
// console.log(Math.abs([]));//0
// console.log(Math.abs({}));//NaN
// console.log(Math.abs(undefined));//NaN
// console.log(Math.abs('-12.5px'));//NaN

// Math.ceil()// 往大了取整(负数也是取大的)
// Math.floor()// 往小了取整(负数也是取小的)

// Math.round()//四舍五入
// console.log(Math.round(-12.1));//-12 
// console.log(Math.round(-12.9));//-13   
// console.log(Math.round(-12.5));//-12  //重点记忆  负数里的.5要舍,正数里的.5是进一位

// Math.max()/Math.min()
// console.log(Math.max(5,98,21,4,5));//98
// console.log(Math.max([5,98,21,4,5]));//NaN

// Math.sqrt()//开平方(负数不能开平方)
// console.log(Math.pow(2,10)); //求次方

//Math.randow()//0-1之间的随机小数
/**获取m-n之间的随机整数
 * Math.round(Math.random()*(n-m)+m)
 */
//  console.log(Math.round(Math.random()));//打印0或者1
// console.log(Math.round(Math.random()*(7-2)+2));// 获取2-7之间的随机整数



/**数组是对象数据类型,它是一种特殊的对象 console.log(typeof []);//'object'
 * 一.数组的增删改方法: 这一部分方法都会修改原有数组
 * 1. push:向数组末尾添加内容
 * @params  多个任意类型
 * @return  新增后数组的长度
 * */
//  let ary=[1,2]
//  let res=ary.push(3,'aa',{name:'hh'})
//  console.log(res,ary)//5 [1,2,3,'aa',{name:'hh'}]
//  ary[ary.length]=100  //也可以新增

// 2.unshift():元素头部添加内容同push()方法

//原生js头部添加
//  let ary=[1,3,5]
// for (let i = ary.length; i > -1; i--) {
//     if(i==0){
//         ary[0]='第1项'
//     }else{
//         ary[i]=ary[i-1]
//     }
// }
// console.log(ary);


//es6头部添加元素
// let ary=[1,3,5]
// ary=['第一项',...ary]
// console.log(ary);

/**3 shift 删除数组第一项
 * @params
 * return 删除的那一项
*/
// let ary=[10,34,56,4]
// let res=ary.shift()
// console.log(res,ary); //10  [34,56,4]
//delete ary[0]:把数组当成普通对象,确实可以删除数组中的某一项,但是不会影响数组本身的结构特点(length不会跟着修改)
// 所以真实项目中杜绝这种删除方法的使用


/**pop() 删除数组最后一项  用法同shift
 * 基于原生js 删除数组最后一项  ary.length--  //ary.length=ary.length-1

/**splice()  实现数组的删除
 * @params  (m,n)  m,n都是数字,表示从索引m开始(包含m),删除n个元素(如果n不写,是一直删除到末尾)
 * @return   把删除的部分用新数组存储起来返回
*/
//   let ary=[10,20,30,40,50,60,70]
// let res=ary.splice(2,3)// 从第2项开始,删除3个元素
// console.log(res,ary);[30,40,50] [10,20,60,70]

// let res=ary.splice(0)//清空数组
// console.log(res,ary)//[10,20,30,40,50,60,70]  []

// let res=ary.splice(0,1)//删除第一项
// console.log(res,ary)//[10]  [20,30,40,50,60,70]

// let res=ary.splice(ary.length-1)//删除最后一项
// console.log(res,ary)//[70]  [10,20,30,40,50,60]


/**splice()  实现数组的修改,增加
 * @params  
 * (m,n,x)  从索引m开始,删除n个元素,用x占用删除的部分,这就是修改元素
 * (m,0,x)  从索引m开始,不删除元素,把x放在索引m元素的前面
 * @return   把删除的部分用新数组存储起来返回
*/
// let res=ary.splice(2,0,'hh','zwt')//任意位置添加元素
// console.log(res,ary);

// let res=ary.splice(ary.length,0,'末尾追加的元素')//尾部添加元素
// console.log(res,ary);

// let res=ary.splice(0,0,'头部追加的元素')
// console.log(res,ary);

// 二 数组的查询和拼接  此组方法,原数组不会改变
// slice() 查找元素
// @params (m,n) 从索引m开始,找到索引为n的地方(不包括n这一项) 如果不写n,则一直找到数组末尾
// @return 把找到的内容以一个新数组的形式返回 
// let ary=[10,20,30,40,50,60,70]

// let res=ary.slice(1,4)
// console.log(res);//[20, 30, 40]

//浅克隆方式 参数0不写也可以
// let res=ary.slice(0)
// console.log(res);//[10,20,30,40,50,60,70]  

/**concat:数组拼接
* @params 多个任意类型值
* @return 拼接后的新数组(原数组不变)
*/
// let ary1=[1,2,3]
// let ary2=[4,5,6]
// let res=ary1.concat('黄杭',ary2)
// console.log(res);//[1, 2, 3, '黄杭', 4, 5, 6]


/**把数组转成字符串. 原有数组不变
 * toString() 数组转成字符串
 * @params
 * @return 转化后的字符串(原有数组不变)
*/
// let ary=[1,2,3]
// let res=ary.toString()
// console.log(res);// '1,2,3'
// [].toString()//''
// [13].toString()//'13'

/**
 * join() 数组转成字符串
 * @params 指定的分隔符(字符串形式),如果不指定分隔符,默认用逗号分割
 * @return 转化后的字符串(原有数组不变)
*/
// let ary=[1,2,3]
// let res=ary.join('-')
// console.log(res);//1-2-3

// let res=ary.join('+')
// console.log(eval(res));//6  eval先将res变为js表达式,再求和

/**检测数组是否包含某一项
 * indexOf/lastIndexOf  检测当前项第一次/最后一次在数组中出现的位置(不兼容ie6-ie8)
 * @params 要检索的这一项
 * @return  这一项出现的位置索引值(数字),如果数组中没有这一项,结果返回-1,原数组不变
*/
// let ary=[1,2,3,4,5,6,2,8]
// console.log(ary.indexOf(2));//1
// console.log(ary.lastIndexOf(2));//6
// console.log(ary.indexOf(100));//-1
// console.log(ary.includes(2));//true  es6的includes方法判断是否包含某项

/**数组的排列/排序
* reverse() 翻转数组
 * @params 
 * @return 排列后的新数组(原数组改变)
*/
// let ary=[20,51,1,6,84,41,17]
// let res=ary.reverse()//其实不需要返回值接收
// console.log(res,ary);//[17, 41, 84, 6, 1, 51, 20]   [17, 41, 84, 6, 1, 51, 20]

/**
 * sort() 数组排序
 * @params 可以没有,也可以是个函数.如果不传参,无法处理10以上的排序
 *         (因为默认按照第一项第一个字符排序,不是我们想要的结果)
 * @return 排序后的新数组(原数组改变)
*/
// console.log(ary.sort());//按照每项的第一个字符顺序排序
//a,b参数是数组中相邻的两项,可以通过打印出来看出来.下面是箭头函数形式的函数写法
// console.log(ary.sort((a,b)=>a-b));//从小到大排序  [1, 6, 17, 20, 41, 51, 84]
// console.log(ary.sort((a,b)=>b-a));//从大到小排序 [84, 51, 41, 20, 17, 6, 1]

/**遍历数组
 * foreach()
 * @params 回调函数
 * @return 没有返回值  原数组不变
*/
// let ary=[20,51,1,6,84,41,17]
// ary.forEach((item,index) => {
//     console.log(`${index}----${item}`);
// });

/**数组去重 **/
//方案1:
// let ary=[1,2,3,4,2,3,4,7,2,2,5,1,1,2]
// let ary2=[]
// ary.forEach(item => {
//     !ary2.includes(item) ? ary2.push(item):null
// });
// console.log(ary2.sort((a,b)=>a-b));//顺便排序了一下

//方案2:数组的前一项和后面每项比较
// for (let i = 0; i < ary.length; i++) {//i<13

//     for (let j = i+1; j < ary.length; j++) {//j=4 j<13-1-0  j=4 j<9
        
//        if (ary[i]===ary[j]) {
//             ary.splice(j,1)
//             //每删除一项,j后面的每一项索引都提前了一位,数组就塌陷一位.数组塌陷后,为了不让i继续累加,我们先把j--
//             j--
        
//        }
//     }
// }
// console.log(ary);


//方案3  对象方法
// let obj={} //创建一个空对象
// //循环数组,把复合条件的每一项存入对象中
// for (let i = 0; i < ary.length; i++) {
//     //判断obj中是否存在当前循环的这一项
//     //不存在这一项的话,对象中对应的这一项值肯定是undefined,就把它添加到对象中
//     if(obj[ary[i]]===undefined){//
//         obj[ary[i]]=''//这里可以是'',也可以是任意值
//     }else{
//         // ary.splice(i,1)
//         // i--

//         //基于splice删除性能不好,当前项被删除,后面每一项的索引都要向前提一位,如果后面内容过多,
//         //一定影响性能,所以可以改进一下上面两行的方法,如下:
//         ary[i]=ary[ary.length-1]//用最后一项替换当前项(当前项在对象中有重复)
//         ary.length--//删除最后一项,因为最后一项已经被提到arr[i]的位置了,所以最后一项不需要了
//         i--//为了仍然要从i的位置比较,为了不让它i++,所以此处i--来抵消i++
//     }
// }
// console.log(ary);
//可以将去重封装成一个函数,我没写

//63课用了正则.new Set()方法,map()也提了一下,没认真看



//字符串
// let str='abcde'
// str.length  str[0]  str[str.length-1]  和数组类似
// str[999]//undefined

/**charAt() 根据索引找出指定位置的字符
 * charCodeAt() 根据索引找出指定位置的ASCII值(Unicode值)
* @params  (n) n是字符的索引
 * @return charAt()返回查找到的字符,找不到则返回''(不是undefined)  charCodeAt()返回对应的编码值
*/
// let str='zheng wen ting'
// console.log(str.charAt(0));  //z
// console.log(str.charAt(100));  //''

// //不常用
// console.log(str.charCodeAt(0));  //122
// console.log(String.fromCharCode(122));//'z'


// 字符串截取 substr substring slice
/**substr(m,n) 从索引m开始,截取n个字符.n不写,就截取到末尾
 * substring(m,n) 从索引m开始,截到索引n的字符串(不含n). n不写,就截取到末尾
 * slice(m,n) 从索引m开始,截到索引n的字符串(不含n). n不写,就截取到末尾,但是slice可以支持负数作为索引,上面两个不可以

*/
// let str='huanghangiscool'
// //第二个参数如果大于字符串长度(比如9999),也是截取到末尾
// console.log(str.substr(1,3));//'uan'
// console.log(str.substring(1,3));//'ua'
// console.log(str.substr(0));//'huanghangiscool'
// console.log(str.substring(0));//'huanghangiscool'

// console.log(str.substring(-1,-3));//'ua'
// console.log(str.slice(-3,-1));//'oo'

/**indexOf/lastIndexOf/includes
 * indexOf(x,[y]) 获取x第一次出现的索引,y是控制查找的起始索引(兼容ie6-8) x可以是一个整体的字符串
 * lastIndexOf(x)  获取x最后一次出现的索引(兼容ie6-8) x可以是一个整体的字符串
 * 上面两个找不到索引的话,就返回-1
*/
// let str='huanghangiscool'
// console.log(str.indexOf('n'));//3
// console.log(str.lastIndexOf('n'));//7


//字符串大小写转换
// str.toUpperCase() str.toLowerCase()


// split([分隔符])  把字符串按照指定分隔符拆分成数组(和数组的join相对应)
//split支持正则
// let str='hh|zwt|hl|sh'
// let ary=str.split('|')
// console.log(ary);//['hh', 'zwt', 'hl', 'sh']
    

// replace([老字符],[新字符])  字符串替换,经常伴随着正则一起使用(如果不使用正则,一次replace只能替换一次)
// let str='黄杭@郑文婷@孙红@郑伟刚'
// str=str.replace(/@/g,'-')
// console.log(str);//黄杭-郑文婷-孙红-郑伟刚

// 66课url截取没怎么听,字符串方法和正则方法,稀里糊涂的

// let time=new Date()  //
// console.log(typeof time);//=>'object' (获取Date这个类的实例对象) 获取本地时间
//属性和方法
// getFullYear() 年
// getMonth()  月 (月是0-11)
// getDate()  日
// getDay()    星期 (0-6 周日到周六)
// getHours() 时
// getMinutes() 分
// getSeconds() 秒  (等于1000毫秒)
//getMilliseconds 毫秒
//getTime  当前时间距离1970/1/1 00:00:00的毫秒差
// toLocaleDateString toLocaleTimeString toLocaleString  返回的都是字符串



// console.log(time.toLocaleDateString());//'2023/1/6'
// console.log(time.toLocaleTimeString());//'22:48:03'
// console.log(time.toLocaleString());//'2023/1/6 22:48:12'
// console.dir(time);

//68课小时钟案列没做

//  数字前可加0,也可不加0,/可以换成-,但-在ie下不支持. 可以只写日期,不写具体时间
//69课后面用的原型方法封装,看不懂
// let addZero=val=>val>9?val:'0'+val
// let time=new Date('2023-5-01 10:15:6'),//为了容错ie,最好先处理一下 '-'
//     year=time.getFullYear(),
//     month=addZero(time.getMonth()+1),
//     date=addZero(time.getDate()),
//     hours=addZero(time.getHours()),
//     minutes=addZero(time.getMinutes()),
//     seconds=addZero(time.getSeconds())
// console.log(`${year}年${month}月${date}日 ${hours}:${minutes}:${seconds}`);

// 70-71里除了 querySelect/querySelectAll,其他没怎么看

节点:Node(页面中所有的东西都是节点)
// 节点集合:NodeList (getElementsByName/querySelectAll 获取的都是节点集合,其他几种方法获取的是元素集合  )
/**
 * 元素节点(元素标签)
    nodeType:1
    nodeName:大写的标签名
    nodeValue:null
 * 
 *文本节点(标准浏览器中会把空格和换行当做文本节点)
    nodeType:3
    nodeName:'#text'
    nodeValue:文本内容
 * 
  *属性节点
    nodeType:8
    nodeName:'#commen'
    nodeValue:注释内容
 * 
 *文档节点
    nodeType:
    nodeName:'#document'
    nodeValue:null
*/
// 描述这些节点之间关系的属性
// childNodes:获取所有的子节点
// parentNode:获取父亲节点

// firstChild:获取第一个子节点
// lastChild:获取最后一个子节点

// previousSibling:获取上一个哥哥节点
// nextSibling:获取下一个哥哥节点

// children:获取所有的元素子节点(子元素标签集合) ,但是child在ie6-ie8会把注释也当做元素节点
// fistElementChild/lastElementChild :获取第一个/最后一个元素子节点(不兼容ie6-ie8)
// previousElementSibling/nextElementSibling 获取 上一个哥哥/下一个弟弟 元素节点(不兼容ie6-ie8)

// 
// 注释节点
// 文档节点  document
// ....

// Dom这块没怎么看,回头再认真看下


/**一.git全局配置
 * $ git config -l  查看配置信息
 * $ git config --global -l  查看配置信息
 * 第一使用需要配置全局信息,即用户名和邮箱:
 * git config --global user.name 'huanghang'
 * git config --global user.email '196381467@qq.com'
 * 
 * 二.创建仓库完成版本控制
 *  1.创建本地git仓库
 *  2.$ git init  //会生成一个隐藏文件夹".git"(该文件夹)
 *  一定不可删除,因为暂存区和离市区还有一些其他的信息都在爱这里,
 *  删了就不再是一个完整的git仓库了 
 *  3.在本地编写代码后(工作区),把一些文件提交到暂存区:
 *     $ git add xxxx  //把某一个文件或者文件夹提交到暂存区
 *     $ git .  //把当前仓库中所有最新修改的文件都提交到暂存区
 *     $ git -A  //同上
 *  
 * 
 * 
*/









</script>
</body>
</html>